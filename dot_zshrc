# vim: ft=zsh
source "${HOME}/.shinit"

for dir in "$HOME"/.config/sh/*; do
  if [[ ! -d $dir ]]; then
    continue
  fi

  if [[ -n $CI ]]; then
    echo "Sourcing ${dir}/init.zsh"
  fi

  if [[ -r ${dir}/init.zsh ]]; then
    source "${dir}/init.zsh"
  fi
done

# Adding this here so scripts think pyenv is initialized
# eval "$(pyenv init -)"

# Set up fpath for my autoloaded functions
fpath=("${HOME}/.config/zsh/" "${fpath[@]}")
autoload -Uz "${HOME}/.config"/zsh/[A-Za-z]*
if [[ -t 0 ]] && [[ -t 1 ]] && [[ -z $CI ]]; then
  autoload -Uz compinit && compinit -C -d "${HOME}/.zcompdump"

  if [[ -f ${NVM_DIR:-${HOME}/.nvm}/bash_completion ]]; then
    source "${NVM_DIR:-${HOME}/.nvm}/bash_completion"
  fi
fi

alias echo_fpath="echo_array fpath"

echo_array() {
  local variable_name="${1:-path}"
  local count="${#${(P)variable_name}}"
  local width="${#count}"
  local i
  for i in {1..$count}; do
    echo "${(l:$width:)i}: ${${(P)variable_name}[$i]}"
  done
}

echo_assoc_array() {
  local key val var_name="$1"
  for key val ("${(@Pkv)var_name}"); do
    echo "$key -> $val"
  done
}

# Use menu for autocompletion when number of items >= 2
zstyle ':completion:*' menu select=2
# Colors for files
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# Verbose completion results
zstyle ':completion:*' verbose true
# Keep directories and files separated
zstyle ':completion:*' list-dirs-first true
# Case insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'l:|=* r:|=*'

DIRSTACKSIZE=8
# If a command is issued that can’t be executed as a normal command, and the
# command is the name of a directory, perform the cd command to that directory
setopt auto_cd
# Make cd push the old directory onto the directory stack
setopt auto_pushd
# Don’t push multiple copies of the same directory onto the directory stack
setopt pushd_ignore_dups
# Exchanges the meanings of ‘+’ and ‘-’ when used with a number to specify a
# directory in the stack
setopt pushd_minus
# Don't print the new working directory after pushd-ing
setopt pushd_silent
# Don't print the new working directory after cd-ing
setopt cd_silent

# Allow comments in the interactive shell
setopt interactive_comments

# The time the shell waits, in hundredths of seconds, for another key to be
# pressed when reading bound multi-character sequences. Useful for vim mode
KEYTIMEOUT=10

# NOTE: If you want to see what a certain keypress makes do CTRL-V <KEYPRESS>

# Default: WORDCHARS="*?_-.[]~=/&;!#$%^(){}<>"
# Remove the / character from the $WORDCHARS
WORDCHARS="${WORDCHARS/\//}"

# Use emacs keybindings. See all bindings with 'bindkey -L'
bindkey -e

autoload -U up-line-or-beginning-search down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey '^P' up-line-or-beginning-search
bindkey '^N' down-line-or-beginning-search
bindkey "^[[A" up-line-or-beginning-search
bindkey "^[[B" down-line-or-beginning-search

autoload -U edit-command-line
zle -N edit-command-line
bindkey '^xe' edit-command-line
bindkey '^x^e' edit-command-line

# Perform history expansion and insert a space into the buffer. If you type a
# space after a command that starts with ! (or ^) to refer to (part of) a
# previous command, that history reference is expanded
bindkey ' ' magic-space
bindkey '^A' beginning-of-line
bindkey '^K' kill-line
bindkey '^W' backward-kill-word
bindkey '^H' backward-delete-char
bindkey '^U' backward-kill-line
bindkey '^R' history-incremental-search-backward
bindkey '^[[1;3C' forward-word # alt-right
bindkey '^[f' forward-word # alt-f
bindkey '^[[1;3D' backward-word # alt-left
bindkey '^[b' backward-word # alt-b
bindkey '^[d' kill-word # alt-d
bindkey '^[#' pound-insert # alt-#
bindkey '^[[Z' reverse-menu-complete # shift-tab
bindkey '^[.' insert-last-word

if command -v fzf &>/dev/null && command -v fd &>/dev/null; then
  fzf-file-widget() {
    # Need extended_glob for trimming $current_word
    setopt localoptions extended_glob
    local -A matched_words
    local current_word lbuffer rbuffer
    autoload -U match-words-by-style && match-words-by-style

    if [[ -n "${matched_words[ws-before-cursor]}" && -n "${matched_words[ws-after-cursor]}" ]] || \
      [[ -n "${matched_words[ws-before-cursor]}" && "${#RBUFFER}" = 0 ]] || \
      [[ -n "${matched_words[ws-after-cursor]}" && "${#LBUFFER}" = 0 ]]; then
      # Whitespace on both sides or at beginning or end
      lbuffer="$LBUFFER"
      rbuffer="$RBUFFER"
    elif [[ -n "${matched_words[ws-before-cursor]}" || ( "$CURSOR" = 0 && -z "${matched_words[ws-after-cursor]}" ) ]]; then
      # Beginning of a word
      current_word="${matched_words[word-after-cursor]}"
      lbuffer="$LBUFFER"
      rbuffer="${BUFFER[$(( CURSOR + ${#matched_words[word-after-cursor]} + 1 )),-1]}"
    elif [[ -n "${matched_words[ws-after-cursor]}" || "$CURSOR" = "${#BUFFER}" ]]; then
      # At end of word
      current_word="${matched_words[word-before-cursor]}"
      lbuffer="${BUFFER[1,$(( CURSOR - ${#matched_words[word-before-cursor]} ))]}"
      rbuffer="$RBUFFER"
    else
      # Inside word
      current_word="${matched_words[word-before-cursor]}${matched_words[word-after-cursor]}"
      lbuffer="${matched_words[start]}${matched_words[ws-before-word]}"
      rbuffer="${matched_words[ws-after-word]}${matched_words[end]}"
    fi
    # Trim leading and trailing whitespace
    current_word="${${current_word##[[:space:]]##}%%[[:space:]]##}"

    if command -v project-find >/dev/null 2>&1; then
      local path="$(project-find -d | fzf --query "$current_word")"
    else
      local path="$(fd --hidden --exclude .git | fzf --query "$current_word")"
    fi
    if [[ "$status" != 0 || -z "$path" ]]; then
      zle reset-prompt
      return
    fi

    LBUFFER="${lbuffer}${path}"
    RBUFFER="$rbuffer"
    zle reset-prompt
  }
  zle -N fzf-file-widget
  bindkey '^T' fzf-file-widget

  fzf-select-history() {
    local command="$(fc -l -n 1 | fzf --tiebreak index --tac --query "$LBUFFER")"
    if [[ "$status" -ne 0 || -z "$command" ]]; then
      return
    fi
    BUFFER="$command"
    CURSOR=$#BUFFER
    zle reset-prompt
  }
  zle -N fzf-select-history
  bindkey '^R' fzf-select-history
fi

# Perform textual history expansion, csh-style, treating the character '!'
# specially.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-BANGHIST
setopt bang_hist

# Save each command’s beginning timestamp (in seconds since the epoch) and the
# duration (in seconds) to the history file. The format of this prefixed data
# is:
#
# ': <beginning time>:<elapsed seconds>;<command>'.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-EXTENDEDHISTORY
setopt extended_history

# This option both imports new commands from the history file, and also causes
# your typed commands to be appended to the history file (the latter is like
# specifying INC_APPEND_HISTORY, which should be turned off if this option is
# in effect). The history lines are also output with timestamps ala
# EXTENDED_HISTORY (which makes it easier to find the spot where we left off
# reading the file after it gets re-written).
#
# By default, history movement commands visit the imported lines as well as the
# local lines, but you can toggle this on and off with the set-local-history
# zle binding. It is also possible to create a zle widget that will make some
# commands ignore imported commands, and some include them.
#
# If you find that you want more control over when commands get imported, you
# may wish to turn SHARE_HISTORY off, INC_APPEND_HISTORY or
# INC_APPEND_HISTORY_TIME (see above) on, and then manually import commands
# whenever you need them using ‘fc -RI’.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-SHAREHISTORY
setopt share_history

# If a new command line being added to the history list duplicates an older
# one, the older command is removed from the list (even if it is not the
# previous event).
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-HISTIGNOREALLDUPS
setopt hist_ignore_all_dups

# Remove command lines from the history list when the first character on the
# line is a space, or when one of the expanded aliases contains a leading
# space. Only normal aliases (not global or suffix aliases) have this
# behaviour. Note that the command lingers in the internal history until the
# next command is entered before it vanishes, allowing you to briefly reuse or
# edit the line. If you want to make it vanish right away without entering
# another command, type a space and press return.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-HISTIGNORESPACE
setopt hist_ignore_space

# Remove superfluous blanks from each command line being added to the history
# list.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-HISTREDUCEBLANKS
setopt hist_reduce_blanks

# Whenever the user enters a line with history expansion, don’t execute the
# line directly; instead, perform history expansion and reload the line into
# the editing buffer.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-history_002c-verifying-substitution
setopt hist_verify

# This option works like APPEND_HISTORY except that new history lines are added
# to the $HISTFILE incrementally (as soon as they are entered), rather than
# waiting until the shell exits. The file will still be periodically re-written
# to trim it when the number of lines grows 20% beyond the value specified by
# $SAVEHIST (see also the HIST_SAVE_BY_COPY option).
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-history_002c-incremental-appending-to-a-file
setopt inc_append_history

# Any potential history entry that matches the pattern is skipped.
# https://zsh.sourceforge.io/Doc/Release/Parameters.html#index-index-HISTORY_005fIGNORE
export HISTIGNORE="ls:ll:la:cd:cd -:pwd:exit:date:* --help"

# The maximum number of history events to save in the history file.
# https://zsh.sourceforge.io/Doc/Release/Parameters.html#index-SAVEHIST
export SAVEHIST=100000

# The maximum number of events stored in the internal history list
# https://zsh.sourceforge.io/Doc/Release/Parameters.html#index-HISTSIZE
export HISTSIZE=100000

# Keep this at the end
if [[ -e "${HOME}/.cache/iterm2/iterm2_shell_integration.zsh" ]]; then
  source "${HOME}/.cache/iterm2/iterm2_shell_integration.zsh" || true
fi

# Added for Gitpod
# Generated for envman. Do not edit.
[ -s "$HOME/.config/envman/load.sh" ] && source "$HOME/.config/envman/load.sh"
