#!/bin/sh

alias ll='ls -l'
alias la='ls -la'

if ! command -v sudoedit >/dev/null; then
  alias sudoedit='sudo --edit'
fi

alias gs='echo_run git status'
alias gb='git-branch'

# 1Password
op_signin() {
  if ! command -v op >/dev/null 2>&1; then
    echo "command not found: op"
    return 127
  fi
  if ! op get account >/dev/null 2>&1; then
    # shellcheck disable=SC2016
    echo_eval 'eval "$(op signin)"'
    # Verify we are signed in now
    op get account >/dev/null 2>&1
  fi
}

if command -v brew >/dev/null; then
  brew() {
    if [ -n "$VIRTUAL_ENV" ]; then
      echo-warn "Don't run brew from inside a venv. https://docs.brew.sh/Homebrew-and-Python"
      env "PATH=$(
        remove_prefix_from_path "$PYENV_ROOT"
        echo "$PATH"
      )" safe_run command brew "$@"
      return $?
    fi
    env "PATH=$(
      remove_prefix_from_path "$PYENV_ROOT"
      echo "$PATH"
    )" command brew "$@" || return $?
  }
fi

remove_prefix_from_path() {
  # NOTE: Removes only a prefix (i.e. $PYENV_ROOT not $PYENV_ROOT/bin)
  while true; do
    case ":$PATH" in
      *:"$1"/*:*) PATH="${PATH%%"${1}"*}${PATH#*"${1}"*:}" ;;
      *"$1"/*) PATH="${PATH%%"${1}"*}" ;;
      *) break ;;
    esac
  done
}

remove_from_path() {
  while [ $# -gt 0 ]; do
    while true; do
      case $PATH in
        "$1")
          unset PATH
          break
          ;;
        "$1:"*) PATH=${PATH#"$1:"} ;;
        *":$1") PATH=${PATH%":$1"} ;;
        *":$1:"*) PATH=${PATH%%":$1:"*}:${PATH#*":$1:"} ;;
        *) break ;;
      esac
    done
    shift
  done
}

autoload_script() {
  # usage: autoload_script func_name /path/to/func_name

  # The outer eval is needed so that the args to autoload_script can be used by
  # the inner function. The inner function (the one created by the outer eval)
  # is needed so that `$(cat $2)` isn't called immediately when
  # `autoload_script` is called. We want `cat` to only be called the first time
  # the the function with the name defined by $1 is called. The inner eval
  # creates the function with the actual body and runs it once. This means that
  # the first time the function is called, it will load in the actual function
  # body and create a new function (with the same name) with the actual
  # business logic. Afterwards the function is fully loaded.
  eval "${1}() {
    eval '${1}() {' \"\$(cat ${2})\" '}; ${1} \"\$@\"'
  }"
}

autoload_script echo_eval "${PRIVATE_BIN}/echo-eval"
autoload_script safe_eval "${PRIVATE_BIN}/safe-eval"
autoload_script echo_run "${PRIVATE_BIN}/echo-run"
autoload_script safe_run "${PRIVATE_BIN}/safe-run"

take() {
  # shellcheck disable=SC2164
  mkdir -p "$1" && cd "$1"
}

alias resh="restart_shell"
restart_shell() {
  # Sometimes the shell will be started with a dash in front of the name of the
  # shell to indicate that it's a login shell. This breaks the restart because
  # exec thinks that the name of the shell is actually an argument.
  if [ $# -eq 0 ]; then
    if [ -f "/proc/$$/cmdline" ]; then
      set -- "$(tr '\0' ' ' <"/proc/$$/cmdline" | cut -d ' ' -f 1)"
    else
      set -- "$(ps -p $$ -o comm | tail -1)"
    fi
  fi
  set -- "${1#-}"
  set -- "$(command -v "$1")"
  if [ -z "$1" ]; then
    set -- "${SHELL:-/bin/zsh}"
  fi

  if command -v zplug >/dev/null 2>&1; then
    echo_run zplug reinit
  fi

  if [ -n "$(jobs)" ]; then
    echo-warn "Current shell has backgrounded jobs. Not restarting ${1}"
    return 1
  fi

  # Since we reset $PATH and the autoloading requires cat (which is in $PATH)
  # preload some functions
  echo_run echo >/dev/null 2>&1
  echo_eval echo >/dev/null 2>&1

  # Try using the awk approach since my original approach didn't handle
  # newlines well
  # for name in $(env | cut -d '=' -f1 | xargs echo); do
  for name in $(awk 'BEGIN{for(v in ENVIRON) print v}' | xargs echo); do
    # These variables are provided by the terminal and are not automatically
    # assigned by the shell
    case "$name" in
      COLORFGBG | COLORTERM | COMMAND_MODE | HOME | ITERM_PROFILE | ITERM_SESSION_ID | LANG | LC_TERMINAL | LC_TERMINAL_VERSION | LOGNAME | PWD | SHELL | SSH_AUTH_SOCK | TERM | TERM_PROGRAM | TERM_PROGRAM_VERSION | TERM_SESSION_ID | TMPDIR | USER | XPC_FLAGS | XPC_SERVICE_NAME | __CFBundleIdentifier | __CF_USER_TEXT_ENCODING) : ;;
      *) echo_run unset "$name" ;;
    esac
  done

  echo_run exec "$1" -li
}

novenv() {
  venv --save
  # All this `trap` stuff makes it so that if I CTRL-C in the running command
  # the virtual environment will still be restored and the exit code will still
  # be correct
  trap '' INT
  (
    trap - INT
    "$@"
  )
  set -- $?
  trap - INT
  venv --restore
  return "$1"
}

tmp() {
  set -- "${TMPDIR}$(date +%Y-%m-%dT%H%M%S)"
  echo_run mkdir -p "$1"
  echo_run cd "$1"
}

venv() {
  while [ $# -gt 0 ]; do
    case "$1" in
      -[[:alnum:]][[:alnum:]]*)
        _value="-${1##-?}"
        _arg="${1%%"${1##-?}"}"
        ;;
    esac
    if [ -n "${_arg:-}${_value:-}" ]; then
      shift
      set -- "$_arg" "$_value" "$@"
    fi
    unset _arg _value
    case "$1" in
      -h | --help)
        echo "Usage: venv [options] [<venv_name>]"
        echo
        echo "Manges virtual environments. Passing no options will attempt to find"
        echo "and activate a virtual environment with the default name (.venv) or "
        echo "<venv_name>."
        echo
        echo "Options:"
        echo "  -c --create --create3  Create a python 3 virtual environment."
        echo "  --create2              Create a python 2 virtual environment."
        echo "  -s --save              Save a virtual environment to the stack."
        echo "  -r --restore           Restore a virtual environment from the stack."
        echo "  -d --deactivate        Deactivate a virtual environment."
        echo
        echo "Examples:"
        echo "  venv  # Activate a virtual environment with the name .venv"
        echo "  venv --create .venv3"
        echo "  venv --save && do_something && venv --restore"
        return
        ;;
      --create2)
        shift
        if [ -n "$VIRTUAL_ENV" ]; then
          echo_run deactivate
        fi
        if [ -d "${1:-.venv}" ]; then
          echo_run rm -rf "${1:-.venv}"
        fi
        echo_run python2 -m pip install virtualenv
        echo_run python2 -m virtualenv "${1:-.venv}"
        echo_run . "${1:-.venv}/bin/activate"
        if [ -f requirements.txt ]; then
          echo_run pip install -r requirements.txt
        fi
        return $?
        ;;
      -s | --save)
        if [ -z "$VIRTUAL_ENV" ]; then
          return
        fi

        echo "\033[2m# Saving venv '${VIRTUAL_ENV}'\033[m"
        SAVED_VENVS="${VIRTUAL_ENV}:${SAVED_VENVS:-}"
        echo_run deactivate
        return $?
        ;;
      -r | --restore)
        if command -v deactivate >/dev/null 2>&1; then
          echo_run deactivate
        fi

        if [ -n "${SAVED_VENVS:-}" ]; then
          echo "\033[2m# Restoring '${SAVED_VENVS%%:*}'\033[m"
          echo_run . "${SAVED_VENVS%%:*}/bin/activate"
          SAVED_VENVS="${SAVED_VENVS#"${SAVED_VENVS%%:*}:"}"
        fi
        return $?
        ;;
      -c | --create | --create3)
        shift
        if [ -n "$VIRTUAL_ENV" ]; then
          echo_run deactivate
        fi
        if [ -d "${1:-.venv}" ]; then
          echo_run rm -rf "${1:-.venv}"
        fi
        echo_run python3 -m venv "${1:-.venv}"
        echo_run . "${1:-.venv}/bin/activate"
        if [ -f requirements.txt ]; then
          echo_run pip install -r requirements.txt
        fi
        return $?
        ;;
      -d | --deactivate)
        if [ -n "$VIRTUAL_ENV" ] && command -v deactivate >/dev/null 2>&1; then
          echo_run deactivate
          return $?
        fi
        return $?
        ;;
      *)
        break
        ;;
    esac
    shift
  done

  # Recursively search up until home directory for a virtual environment with
  # the desired name. This allows you to activate a venv from the root of your
  # project while you're deep in the directory structure
  set -- "${1:-.venv}" "$PWD" "$1"
  while [ "$2" != "$HOME" ] && [ "$2" != "/" ] && [ ! -f "${2}/${1}/bin/activate" ]; do
    set -- "$1" "$(dirname "$2")" "$3"
  done

  # If you're in a venv and you didn't specify a different one explicitly then
  # you probably want to deactivate the current one
  if [ -n "$VIRTUAL_ENV" ] && [ -z "$3" ]; then
    echo_run deactivate
    return
  fi

  if [ ! -f "${2}/${1}/bin/activate" ]; then
    echo-err "Couldn't find a valid venv for '${1}'"
    return 1
  fi

  # shellcheck disable=SC1090
  echo_run . "${2}/${1}/bin/activate"
}

dotfiles() {
  if [ $# -eq 0 ]; then
    command dotfiles
    return $?
  fi
  case "$1" in
    'cd')
      shift
      if command -v deactivate >/dev/null 2>&1; then
        # When going from some directory where I have a venv activated to the
        # dotfiles directory, I almost never want to actually stay in that
        # virtual environment and have to run `deactivate` manually.
        echo_run deactivate
      fi
      echo_run cd "$(chezmoi source-path "$@")"
      ;;
    *)
      if command -v op >/dev/null 2>&1; then
        op_signin || return "$?"
      fi
      command dotfiles "$@"
      ;;
  esac
}

workspace() {
  if [ -d "/opt/workspace" ]; then
    echo_run cd /opt/workspace || true
  elif [ -d "${HOME}/Code" ]; then
    echo_run cd "${HOME}/Code" || true
  else
    echo-err "No workspace set"
  fi
}

for dir in "$HOME"/.config/sh/*/; do
  [ -d "$dir" ] || continue

  # shellcheck disable=SC1090
  [ -r "${dir}init.sh" ] && . "${dir}init.sh"
done

if [ -n "$VIRTUAL_ENV" ]; then
  # Allows you to `rc` (reload config, see aliases below) from inside a virtual
  # environment without losing the virtual environment. Normally `exec` keeps
  # all environment variables, but certain ones get overwritten during zsh
  # initialization. This reinitializes them. Keep this after anything else that
  # sets the path.

  # Clean the front of $PATH. This is really only used when starting a subshell
  # while in a virtual environment
  remove_prefix_from_path "$VIRTUAL_ENV"

  # shellcheck disable=SC1090
  echo_run . "$VIRTUAL_ENV/bin/activate"
fi
