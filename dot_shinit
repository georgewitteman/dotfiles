#!/bin/sh

# I'm putting this near the top because sometimes other stuff in this script
# breaks while I'm testing it and then restart_shell isn't loaded and I have to
# remember what this actually does.
alias resh="restart_shell"
restart_shell() {
  # Note: You can't use $0 here since it will be the name of the function, not
  # the shell.
  if [ $# -eq 0 ]; then
    if [ -f "/proc/$$/cmdline" ]; then
      set -- "$(tr '\0' ' ' <"/proc/$$/cmdline" | cut -d ' ' -f 1)"
    else
      set -- "$(ps -p $$ -o comm | tail -1)"
    fi
  fi
  # $1: The name of the shell prefixed with a dash (indicating a login shell)
  # $2: The path to the shell. This is necessary since we get rid of $PATH
  #
  # Sometimes the shell will be started with a dash in front of the name of the
  # shell to indicate that it's a login shell. This breaks the restart because
  # exec thinks that the name of the shell is actually an argument.
  set -- "-$(basename "${1#-}")" "$(command -v "${1#-}")"
  case "$1" in
    # The login command will prefix the name of the shell with a dash. The -p
    # argument tells login to not discard previous environment variables.
    #
    # IMPORTANT: This is not needed anymore. I realized you can use -a${1} in
    # the bash solution below.
    #
    # -*) set -- "$(command -v login)" -p -f "$USER" "$2" ;;
    #
    # The bash exec command has the -a argument which allows you to set the
    # name of the script. This allows us to keep $0 the same across processes.
    # For example, if I originally started bash by typing `bash`, $0 will
    # continue to be `bash`. If I started it with `/bin/bash`, it will continue
    # to be `/bin/bash/`.
    *) set -- "$(command -v bash)" -c "exec -a${1} ${2}" ;;
  esac

  # In case ~/.shinit breaks before loading these functions, set dummy versions
  # of them here so things still work.
  if ! command -v echo_run >/dev/null 2>&1; then
    echo_run() {
      echo "\$ $*"
      "$@"
    }
  fi
  if ! command -v echo_eval >/dev/null 2>&1; then
    echo_eval() {
      echo "\$ $*"
      eval "$*"
    }
  fi

  if command -v zplug >/dev/null 2>&1; then
    echo_run zplug reinit
  fi

  if [ -n "$(jobs)" ]; then
    # Handle any issues where $PATH doesn't include my custom echo-warn
    # command.
    if command -v echo-warn >/dev/null 2>&1; then
      echo-warn "Current shell has backgrounded jobs. Not restarting ${1}"
    else
      echo "Current shell has backgrounded jobs. Not restarting ${1}"
    fi
    return 1
  fi

  # Since we reset $PATH and the autoloading requires cat (which is in $PATH)
  # preload some functions.
  echo_run : >/dev/null 2>&1
  echo_eval : >/dev/null 2>&1

  # I'm using the awk approach since my original approach didn't handle
  # newlines well.
  #
  # Original approach: for name in $(env | cut -d '=' -f1 | xargs echo); do
  for name in $(awk 'BEGIN{for(v in ENVIRON) print v}' | xargs echo); do
    case "$name" in
      # These variables are provided by the terminal and are not automatically
      # assigned by the shell.
      COLORFGBG | COLORTERM | COMMAND_MODE | HOME | ITERM_PROFILE | ITERM_SESSION_ID | LANG | LC_TERMINAL | LC_TERMINAL_VERSION | LOGNAME | PWD | SHELL | SSH_AUTH_SOCK | TERM | TERM_PROGRAM | TERM_PROGRAM_VERSION | TERM_SESSION_ID | TMPDIR | USER | XPC_FLAGS | XPC_SERVICE_NAME | __CFBundleIdentifier | __CF_USER_TEXT_ENCODING | OP_SESSION_*) : ;;
      *) echo_run unset -v "$name" ;;
    esac
  done

  echo_run exec "$@"
}

login_shell() {
  # Starts a login shell with the most prestine environment possible.
  echo_run login -f "$USER" "$(command -v env)"
  echo_run exec login -f "$USER"
}

# `man ls`: auto will make ls output escape sequences based on termcap(5), but
# only if stdout is a tty and either the -G flag is specified or the COLORTERM
# environment variable is set and not empty.
alias ls='ls --color=auto'
alias ll='ls -l'
alias la='ls -la'

if ! command -v sudoedit >/dev/null; then
  alias sudoedit='sudo --edit'
fi

alias gs='echo_run git status'
alias gb='git-branch'

# 1Password
op_signin() {
  if ! command -v op >/dev/null 2>&1; then
    echo "command not found: op"
    return 127
  fi
  if ! op account get >/dev/null 2>&1; then
    # shellcheck disable=SC2016
    echo_eval 'eval "$(op signin)"'
    # Verify we are signed in now
    op account get >/dev/null 2>&1
  fi
}

if command -v brew >/dev/null; then
  brew() {
    if [ -n "$VIRTUAL_ENV" ]; then
      echo-warn "Don't run brew from inside a venv. https://docs.brew.sh/Homebrew-and-Python"
      env "PATH=$(
        remove_prefix_from_path "$PYENV_ROOT"
        echo "$PATH"
      )" safe-run command brew "$@"
      return $?
    fi
    env "PATH=$(
      remove_prefix_from_path "$PYENV_ROOT"
      echo "$PATH"
    )" command brew "$@" || return $?
  }
fi

remove_prefix_from_path() {
  # NOTE: Removes only a prefix (i.e. $PYENV_ROOT not $PYENV_ROOT/bin)
  while true; do
    case ":$PATH" in
      *:"$1"/*:*) PATH="${PATH%%"${1}"*}${PATH#*"${1}"*:}" ;;
      *"$1"/*) PATH="${PATH%%"${1}"*}" ;;
      *) break ;;
    esac
  done
}

remove_from_path() {
  while [ $# -gt 0 ]; do
    while true; do
      case $PATH in
        "$1")
          unset PATH
          break
          ;;
        "$1:"*) PATH=${PATH#"$1:"} ;;
        *":$1") PATH=${PATH%":$1"} ;;
        *":$1:"*) PATH=${PATH%%":$1:"*}:${PATH#*":$1:"} ;;
        *) break ;;
      esac
    done
    shift
  done
}

autoload_script() {
  # usage: autoload_script func_name /path/to/func_name

  # The outer eval is needed so that the args to autoload_script can be used by
  # the inner function. The inner function (the one created by the outer eval)
  # is needed so that `$(cat $2)` isn't called immediately when
  # `autoload_script` is called. We want `cat` to only be called the first time
  # the the function with the name defined by $1 is called. The inner eval
  # creates the function with the actual body and runs it once. This means that
  # the first time the function is called, it will load in the actual function
  # body and create a new function (with the same name) with the actual
  # business logic. Afterwards the function is fully loaded.
  #
  # Another thing to note is that the inner eval needs to have the `$(cat $2)`
  # as a double quoted argument. This is so that the output of the command (the
  # function/script implementation) is treated as an argument. If it's not, any
  # quotes in the function/script implementation risk closing the quotes in the
  # code that is being `eval`d, leading to weird bugs. For example:
  # - eval 'foo() { #!/bin/sh
  #   echo 'bar || baz'
  #   }'
  # This is an overly simplistic example, but you can see how the first single
  # quote on line 2 will actually end the string that is the first argument to
  # eval. The `||` will then be treated as a real or (i.e. `echo ... || baz
  # ...`) instead of as part of the string 'bar || baz'.
  eval "${1}() {
    eval \"
      ${1}() {
        \$(cat ${2})
      }
    ${1} \\\"\\\$@\\\"\"
  }"
}

autoload_script echo_eval "${PRIVATE_BIN}/echo-eval"
autoload_script safe_eval "${PRIVATE_BIN}/safe-eval"
autoload_script echo_run "${PRIVATE_BIN}/echo-run"
autoload_script safe_run "${PRIVATE_BIN}/safe-run"

take() {
  # shellcheck disable=SC2164
  mkdir -p "$1" && cd "$1"
}

novenv() {
  venv --save
  # All this `trap` stuff makes it so that if I CTRL-C in the running command
  # the virtual environment will still be restored and the exit code will still
  # be correct
  trap '' INT
  (
    trap - INT
    "$@"
  )
  set -- $?
  trap - INT
  venv --restore
  return "$1"
}

tmp() {
  set -- "${TMPDIR:-"$(mktemp -d)/"}$(date +%Y-%m-%dT%H%M%S)"
  echo_run mkdir -p "$1"
  echo_run cd "$1"
}

venv() {
  while [ $# -gt 0 ]; do
    case "$1" in
      -[[:alnum:]][[:alnum:]]*)
        _value="-${1##-?}"
        _arg="${1%%"${1##-?}"}"
        ;;
    esac
    if [ -n "${_arg:-}${_value:-}" ]; then
      shift
      set -- "$_arg" "$_value" "$@"
    fi
    unset _arg _value
    case "$1" in
      -h | --help)
        echo "Usage: venv [options] [<venv_name>]"
        echo
        echo "Manges virtual environments. Passing no options will attempt to find"
        echo "and activate a virtual environment with the default name (.venv) or "
        echo "<venv_name>."
        echo
        echo "Options:"
        echo "  -c --create --create3  Create a python 3 virtual environment."
        echo "  --create2              Create a python 2 virtual environment."
        echo "  -s --save              Save a virtual environment to the stack."
        echo "  -r --restore           Restore a virtual environment from the stack."
        echo "  -d --deactivate        Deactivate a virtual environment."
        echo
        echo "Examples:"
        echo "  venv  # Activate a virtual environment with the name .venv"
        echo "  venv --create .venv3"
        echo "  venv --save && do_something && venv --restore"
        return
        ;;
      --create2)
        shift
        if [ -n "$VIRTUAL_ENV" ]; then
          echo_run deactivate
        fi
        if [ -d "${1:-.venv}" ]; then
          echo_run rm -rf "${1:-.venv}"
        fi
        echo_run python2 -m pip install virtualenv
        echo_run python2 -m virtualenv "${1:-.venv}"
        echo_run . "${1:-.venv}/bin/activate"
        if [ -f requirements.txt ]; then
          echo_run pip install -r requirements.txt
        fi
        return $?
        ;;
      -s | --save)
        if [ -z "$VIRTUAL_ENV" ]; then
          return
        fi

        echo "\033[2m# Saving venv '${VIRTUAL_ENV}'\033[m"
        SAVED_VENVS="${VIRTUAL_ENV}:${SAVED_VENVS:-}"
        echo_run deactivate
        return $?
        ;;
      -r | --restore)
        if command -v deactivate >/dev/null 2>&1; then
          echo_run deactivate
        fi

        if [ -n "${SAVED_VENVS:-}" ]; then
          echo "\033[2m# Restoring '${SAVED_VENVS%%:*}'\033[m"
          echo_run . "${SAVED_VENVS%%:*}/bin/activate"
          SAVED_VENVS="${SAVED_VENVS#"${SAVED_VENVS%%:*}:"}"
        fi
        return $?
        ;;
      -c | --create | --create3)
        shift
        if [ -n "$VIRTUAL_ENV" ]; then
          echo_run deactivate
        fi
        if [ -d "${1:-.venv}" ]; then
          echo_run rm -rf "${1:-.venv}"
        fi
        echo_run python3 -m venv "${1:-.venv}"
        echo_run . "${1:-.venv}/bin/activate"
        if [ -f requirements.txt ]; then
          echo_run pip install -r requirements.txt
        fi
        return $?
        ;;
      -d | --deactivate)
        if [ -n "$VIRTUAL_ENV" ] && command -v deactivate >/dev/null 2>&1; then
          echo_run deactivate
          return $?
        fi
        return $?
        ;;
      *)
        break
        ;;
    esac
    shift
  done

  # Recursively search up until home directory for a virtual environment with
  # the desired name. This allows you to activate a venv from the root of your
  # project while you're deep in the directory structure
  set -- "${1:-.venv}" "$PWD" "$1"
  while [ "$2" != "$HOME" ] && [ "$2" != "/" ] && [ ! -f "${2}/${1}/bin/activate" ]; do
    set -- "$1" "$(dirname "$2")" "$3"
  done

  # If you're in a venv and you didn't specify a different one explicitly then
  # you probably want to deactivate the current one
  if [ -n "$VIRTUAL_ENV" ] && [ -z "$3" ]; then
    echo_run deactivate
    return
  fi

  if [ ! -f "${2}/${1}/bin/activate" ]; then
    echo-err "Couldn't find a valid venv for '${1}'"
    return 1
  fi

  # shellcheck source=/dev/null
  echo_run . "${2}/${1}/bin/activate"
}

dotfiles() {
  if [ $# -eq 0 ]; then
    command dotfiles
    return $?
  fi
  case "$1" in
    'cd')
      shift
      if command -v deactivate >/dev/null 2>&1; then
        # When going from some directory where I have a venv activated to the
        # dotfiles directory, I almost never want to actually stay in that
        # virtual environment and have to run `deactivate` manually.
        echo_run deactivate
      fi
      echo_run cd "$(chezmoi source-path "$@")"
      ;;
    *)
      # Commenting this out for now since it's not actually used anywhere
      # if command -v op >/dev/null 2>&1; then
      #   op_signin || return "$?"
      # fi
      command dotfiles "$@"
      ;;
  esac
}

work() {
  if [ -d "/opt/workspace" ]; then
    set -- "/opt/workspace"
  elif [ -d "${HOME}/Code" ]; then
    set -- "${HOME}/Code"
  elif [ -d "/workspace" ]; then
    set -- "/workspace"
  else
    echo-err "No workspace set"
    return 1
  fi
  set -- "$1" "$1"/*
  if [ $# -eq 2 ]; then
    cd "$2" || return $?
    return $?
  fi
  cd "$1" || return $?
}

for dir in "$HOME"/.config/sh/*; do
  if [ ! -d "$dir" ]; then
    continue
  fi

  if [ -r "${dir}/init.sh" ]; then
    # shellcheck source=/dev/null
    . "${dir}/init.sh"
  fi
done

if [ -n "$VIRTUAL_ENV" ]; then
  # Allows you to `rc` (reload config, see aliases below) from inside a virtual
  # environment without losing the virtual environment. Normally `exec` keeps
  # all environment variables, but certain ones get overwritten during zsh
  # initialization. This reinitializes them. Keep this after anything else that
  # sets the path.

  # Clean the front of $PATH. This is really only used when starting a subshell
  # while in a virtual environment
  remove_prefix_from_path "$VIRTUAL_ENV"

  # shellcheck source=/dev/null
  echo_run . "$VIRTUAL_ENV/bin/activate"
fi
