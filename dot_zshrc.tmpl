# vim: ft=zsh
source "${HOME}/.shinit"

{{ template "prompt/init.zsh" }}
# Adding this here so scripts think pyenv is initialized
# eval "$(pyenv init -)"

fpath=(
  "${HOME}/.local/share/zsh/functions"
  "${HOME}/.local/share/zsh/zsh-completions/src"
  "${fpath[@]}"
)

# https://docs.brew.sh/Shell-Completion
if [ -n "${HOMEBREW_PREFIX}" ]; then
  fpath=("${HOMEBREW_PREFIX}/share/zsh/site-functions" "${fpath[@]}")
fi

# Note: Any of the strings ‘true’, ‘on’, ‘yes’, and ‘1’ can be used for the
# value ‘true’ and any of the strings ‘false’, ‘off’, ‘no’, and ‘0’ for the
# value ‘false’.
#
# https://zsh.sourceforge.io/Doc/Release/Completion-System.html#Control-Functions
#
# Note: default is '_complete _ignored'.
#
# _expand_alias: If the word the cursor is on is an alias, it is expanded and
# no other completers are called. The types of aliases which are to be expanded
# can be controlled with the styles regular, global and disabled.
#
# _complete: This completer generates all possible completions in a
# context-sensitive manner, i.e. using the settings defined with the compdef
# function explained above and the current settings of all special parameters.
# This gives the normal completion behaviour.
zstyle ':completion:*' completer _expand_alias _complete
# zstyle ':completion:*' completer _expand _complete _ignored _correct _approximate
# Use menu for autocompletion when number of items >= 2.
zstyle ':completion:*' menu select=2
# Verbose completion results.
zstyle ':completion:*' verbose true
# Keep directories and files separated.
zstyle ':completion:*' list-dirs-first true
# https://zsh.sourceforge.io/Guide/zshguide06.html#l170
# https://zsh.sourceforge.io/Doc/Release/Completion-System.html#index-matcher_002dlist_002c-completion-style
# 1. Simple completion
# 2. Case insensitive completion
# 3. Partial word completion
zstyle ':completion:*' matcher-list '' 'm:{a-zA-Z}={A-Za-z}' 'l:|=* r:|=*'
# Colors for files
# - https://zsh.sourceforge.io/Doc/Release/Zsh-Modules.html#The-zsh_002fcomplist-Module
# - https://zsh.sourceforge.io/Doc/Release/Completion-System.html
# - https://gist.github.com/thomd/7667642
# - I'm setting this to the same as the default for macOS `ls`. I got the
# default (exfxcxdxbxegedabagacad) from `man ls` and then used [this
# website](https://geoff.greer.fm/lscolors/) to convert that to LS_COLORS
# format and then used `echo ${(s.:.)LS_COLORS}` to separate that out into
# spaces.
zstyle ':completion:*' list-colors "di=34" "ln=35" "so=32" "pi=33" "ex=31" "bd=34;46" "cd=34;43" "su=30;41" "sg=30;46" "tw=30;42" "ow=30;43"

# https://github.com/zsh-users/zsh/blob/master/Completion/compinit
autoload -Uz compinit
compinit

if [[ -f ${NVM_DIR:-${HOME}/.nvm}/bash_completion ]]; then
  source "${NVM_DIR:-${HOME}/.nvm}/bash_completion"
fi

alias echo_fpath="echo_array fpath"

# https://github.com/zsh-users/zsh/blob/00d20ed15e18f5af682f0daec140d6b8383c479a/StartupFiles/zshrc#L23
alias mv='nocorrect mv'       # no spelling correction on mv
alias cp='nocorrect cp'       # no spelling correction on cp
alias mkdir='nocorrect mkdir' # no spelling correction on mkdir

echo_array() {
  local variable_name="${1:-path}"
  local count="${#${(P)variable_name}}"
  local width="${#count}"
  local i
  for i in {1..$count}; do
    echo "${(l:$width:)i}: ${${(P)variable_name}[$i]}"
  done
}

echo_assoc_array() {
  local key val var_name="$1"
  for key val ("${(@Pkv)var_name}"); do
    echo "$key -> $val"
  done
}

# If a command is issued that can’t be executed as a normal command, and the
# command is the name of a directory, perform the cd command to that directory
setopt auto_cd
# Make cd push the old directory onto the directory stack
setopt auto_pushd
# Don’t push multiple copies of the same directory onto the directory stack
setopt pushd_ignore_dups
# Exchanges the meanings of ‘+’ and ‘-’ when used with a number to specify a
# directory in the stack
setopt pushd_minus
# Don't print the new working directory after pushd-ing
setopt pushd_silent
# Don't print the new working directory after cd-ing
setopt cd_silent

# Allow comments in the interactive shell
setopt interactive_comments

# The time the shell waits, in hundredths of seconds, for another key to be
# pressed when reading bound multi-character sequences. Useful for vim mode
KEYTIMEOUT=10

# NOTE: If you want to see what a certain keypress makes do CTRL-V <KEYPRESS>

# Default: WORDCHARS="*?_-.[]~=/&;!#$%^(){}<>"
# Remove the / character from the $WORDCHARS
WORDCHARS="${WORDCHARS/\//}"

# Use emacs keybindings. See all bindings with 'bindkey -L'
bindkey -e

autoload -U up-line-or-beginning-search down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey '^P' up-line-or-beginning-search
bindkey '^N' down-line-or-beginning-search
bindkey "^[[A" up-line-or-beginning-search # up
bindkey "^[[B" down-line-or-beginning-search # down

autoload -U edit-command-line
zle -N edit-command-line
bindkey '^xe' edit-command-line
bindkey '^x^e' edit-command-line

# Perform history expansion and insert a space into the buffer. If you type a
# space after a command that starts with ! (or ^) to refer to (part of) a
# previous command, that history reference is expanded
bindkey ' ' magic-space
bindkey '^A' beginning-of-line
bindkey '^K' kill-line
bindkey '^W' backward-kill-word
bindkey '^H' backward-delete-char
bindkey '^U' backward-kill-line
bindkey '^R' history-incremental-search-backward
bindkey '^[[1;3C' forward-word # alt-right
bindkey '^[f' forward-word # alt-f
bindkey '^[[1;3D' backward-word # alt-left
bindkey '^[b' backward-word # alt-b
bindkey '^[d' kill-word # alt-d
bindkey '^[#' pound-insert # alt-#
bindkey '^[[Z' reverse-menu-complete # shift-tab
bindkey '^[.' insert-last-word # alt-.

if command -v fzf &>/dev/null; then
  fzf-file-widget() {
    # Need extended_glob for trimming $current_word
    setopt localoptions extended_glob
    local -A matched_words
    local current_word lbuffer rbuffer
    autoload -U match-words-by-style && match-words-by-style

    if [[ -n "${matched_words[ws-before-cursor]}" && -n "${matched_words[ws-after-cursor]}" ]] || \
      [[ -n "${matched_words[ws-before-cursor]}" && "${#RBUFFER}" = 0 ]] || \
      [[ -n "${matched_words[ws-after-cursor]}" && "${#LBUFFER}" = 0 ]]; then
      # Whitespace on both sides or at beginning or end
      lbuffer="$LBUFFER"
      rbuffer="$RBUFFER"
    elif [[ -n "${matched_words[ws-before-cursor]}" || ( "$CURSOR" = 0 && -z "${matched_words[ws-after-cursor]}" ) ]]; then
      # Beginning of a word
      current_word="${matched_words[word-after-cursor]}"
      lbuffer="$LBUFFER"
      rbuffer="${BUFFER[$(( CURSOR + ${#matched_words[word-after-cursor]} + 1 )),-1]}"
    elif [[ -n "${matched_words[ws-after-cursor]}" || "$CURSOR" = "${#BUFFER}" ]]; then
      # At end of word
      current_word="${matched_words[word-before-cursor]}"
      lbuffer="${BUFFER[1,$(( CURSOR - ${#matched_words[word-before-cursor]} ))]}"
      rbuffer="$RBUFFER"
    else
      # Inside word
      current_word="${matched_words[word-before-cursor]}${matched_words[word-after-cursor]}"
      lbuffer="${matched_words[start]}${matched_words[ws-before-word]}"
      rbuffer="${matched_words[ws-after-word]}${matched_words[end]}"
    fi
    # Trim leading and trailing whitespace
    current_word="${${current_word##[[:space:]]##}%%[[:space:]]##}"

    if command -v project-find &>/dev/null; then
      local path="$(project-find -d | fzf --query "$current_word")"
    elif command -v fd &>/dev/null; then
      local path="$(fd --hidden --exclude .git | fzf --query "$current_word")"
    elif command -v fdfind &>/dev/null; then
      local path="$(fdfind --hidden --exclude .git | fzf --query "$current_word")"
    else
      local path="$(find . -not -name '.' -not -name "*.swp" -not -path "*/\.git/*" -not -name "tags" | fzf --query "$current_word")"
    fi
    if [[ "$?" != 0 || -z "$path" ]]; then
      zle reset-prompt
      return
    fi

    LBUFFER="${lbuffer}${path}"
    RBUFFER="$rbuffer"
    zle reset-prompt
  }
  zle -N fzf-file-widget
  bindkey '^T' fzf-file-widget

  fzf-select-history() {
    # fc:
    #   -n 1: suppress event (i.e. history entry) numbers when listing
    #   -l: list commands instead of invoking an editor on them
    # fzf:
    #   --tac: reverse the order of input
    local command="$(fc -l -n 1 | fzf --tiebreak index --tac --query "$LBUFFER")"
    if [[ $? -ne 0 || -z "$command" ]]; then
      return
    fi
    BUFFER="$command"
    CURSOR=$#BUFFER
    zle reset-prompt
  }
  zle -N fzf-select-history
  bindkey '^R' fzf-select-history
fi

# Perform textual history expansion, csh-style, treating the character '!'
# specially.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-BANGHIST
setopt bang_hist

# Save each command’s beginning timestamp (in seconds since the epoch) and the
# duration (in seconds) to the history file. The format of this prefixed data
# is:
#
# ': <beginning time>:<elapsed seconds>;<command>'.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-EXTENDEDHISTORY
setopt extended_history

# This option both imports new commands from the history file, and also causes
# your typed commands to be appended to the history file (the latter is like
# specifying INC_APPEND_HISTORY, which should be turned off if this option is
# in effect). The history lines are also output with timestamps ala
# EXTENDED_HISTORY (which makes it easier to find the spot where we left off
# reading the file after it gets re-written).
#
# By default, history movement commands visit the imported lines as well as the
# local lines, but you can toggle this on and off with the set-local-history
# zle binding. It is also possible to create a zle widget that will make some
# commands ignore imported commands, and some include them.
#
# If you find that you want more control over when commands get imported, you
# may wish to turn SHARE_HISTORY off, INC_APPEND_HISTORY or
# INC_APPEND_HISTORY_TIME (see above) on, and then manually import commands
# whenever you need them using ‘fc -RI’.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-SHAREHISTORY
setopt share_history

# If a new command line being added to the history list duplicates an older
# one, the older command is removed from the list (even if it is not the
# previous event).
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-HISTIGNOREALLDUPS
setopt hist_ignore_all_dups

# Remove command lines from the history list when the first character on the
# line is a space, or when one of the expanded aliases contains a leading
# space. Only normal aliases (not global or suffix aliases) have this
# behaviour. Note that the command lingers in the internal history until the
# next command is entered before it vanishes, allowing you to briefly reuse or
# edit the line. If you want to make it vanish right away without entering
# another command, type a space and press return.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-HISTIGNORESPACE
setopt hist_ignore_space

# Remove superfluous blanks from each command line being added to the history
# list.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-HISTREDUCEBLANKS
setopt hist_reduce_blanks

# Whenever the user enters a line with history expansion, don’t execute the
# line directly; instead, perform history expansion and reload the line into
# the editing buffer.
# https://zsh.sourceforge.io/Doc/Release/Options.html#index-history_002c-verifying-substitution
setopt hist_verify

# The maximum number of history events to save in the history file.
# https://zsh.sourceforge.io/Doc/Release/Parameters.html#index-SAVEHIST
SAVEHIST=100000

# The maximum number of events stored in the internal history list
# https://zsh.sourceforge.io/Doc/Release/Parameters.html#index-HISTSIZE
HISTSIZE="${SAVEHIST:-100000}"

if [ "$CODESPACES" = "true" ] && [ -d "/workspaces/.codespaces/.persistedshare" ]; then
  HISTFILE="/workspaces/.codespaces/.persistedshare/.zsh_history"
fi

# Keep this at the end
if [[ -e "${HOME}/.cache/iterm2/iterm2_shell_integration.zsh" ]]; then
  source "${HOME}/.cache/iterm2/iterm2_shell_integration.zsh" || true
fi

# Added for Gitpod
# Generated for envman. Do not edit.
if [[ -s "$HOME/.config/envman/load.sh" ]];then
  source "$HOME/.config/envman/load.sh"
fi
