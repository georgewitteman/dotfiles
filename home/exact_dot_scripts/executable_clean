#!/bin/sh

set -o errexit

USAGE="usage: $(basename "$0") [-y] (pycache|ds_store|venv|node_modules)"

cmd=safe-run

while getopts y f; do
  case "$f" in
    y) cmd=echo-run ;;
    \?)
      echo "$USAGE"
      exit 1
      ;;
  esac
  shift
done

if [ $# -eq 0 ]; then
  echo "$USAGE"
  exit 1
fi

clean_pycache() {
  echo "cleaning __pycache__ and .pyc files"
  "$cmd" find "$PWD" -type d -a -name '__pycache__' -print -delete
  "$cmd" find "$PWD" -type f -name '*.pyc' -print -delete
}

clean_ds_store() {
  echo "cleaning .DS_Store files"
  "$cmd" find "$PWD" -type f -name ".DS_Store" -print -delete
}

clean_venvs() {
  echo "cleaning venvs"
  find "$PWD" -type f -path '*/bin/activate' | while read -r line; do dirname "$(dirname "$line")"; done | xargs -o "$cmd" rm -rf
}

clean_node_modules() {
  echo "cleaning node_modules folders"
  # It seems like -prune is ignored when using -delete
  find . -name "node_modules" -type d -prune | xargs -o "$cmd" rm -rf
}

for kind in "$@"; do
  case "$kind" in
    pycache) fn=clean_pycache ;;
    ds_store | dsstore) fn=clean_ds_store ;;
    venv | venvs) fn=clean_venvs ;;
    node_modules | nodemodules) fn=clean_node_modules ;;
    *)
      echo "error: cannot clean ${kind}" >&2
      exit 1
      ;;
  esac

  if ! eval "${fn}"; then
    echo "error: failed to clean ${kind}" >&2
  fi
done
