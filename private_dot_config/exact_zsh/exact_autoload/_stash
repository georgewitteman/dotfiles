#compdef stash

_stash() {
  zstyle ':completion:*:*:stash:*:*' list-grouped false

  local git_root="$(git rev-parse --show-toplevel)" 2>/dev/null
  if [[ "$git_root" = "" ]]; then
    _message -r "Not in a git repository."
    return
  fi

  _stashes() {
    [[ -f "$git_root/.git/logs/refs/stash" ]] || return
    local copmletions=()
    local stashes=("${(f)$(<$git_root/.git/logs/refs/stash)}")
    [[ "${#stashes}" -eq 0 ]] && return
    for index in {1..$#stashes}; do
      local stash="${stashes[$index]}"
      local msg=${${(@ps:\t:)stash}[2]}
      completions+=("$(( $index - 1 )):$msg")
    done
    _describe "stashes" completions
  }

  if [[ "${#words}" -eq 2 ]]; then
    local completions=()
    completions+=("show:git stash show stash@{X} -p")
    completions+=("list:git stash list -p")
    completions+=("unstaged:git stash --keep-index")
    completions+=("pip:git stash pop stash@{X}")
    completions+=("apply:git stash apply@{X}")
    completions+=("drop:git stash drop@{X}")
    completions+=("clear:git stash clear")
    completions+=("all:git stash --include-untracked")
    completions+=("staged:git stash push <staged-files>")
    completions+=("patch:git stash --patch")
    _stashes
    _describe "completions" completions
  elif [[ "${#words}" -eq 3 ]]; then
    local commands_with_params=(show pop apply drop)
    if (( ${commands_with_params[(I)${words[2]}]} )); then
      _stashes
    fi
  fi
}
