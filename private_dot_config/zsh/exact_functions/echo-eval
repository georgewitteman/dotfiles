#!/usr/bin/env zsh

autoload -U colors && colors

# This is used to allow echoing commands that have special characters like &&.
# Instead of passing each param as an argument the entire command must be
# passed as a string. If there are multiple string arguments they are
# concatenated together by a space and eval'd as a whole.

# Note: `arr=(a b c) && echo "${(j:-:)arr}"` --> "a-b-c"
# http://zsh.sourceforge.net/Doc/Release/Expansion.html#Parameter-Expansion

# ECHO_RUN_DEBUG: Set to "1" to output command but not run it
# ECHO_RUN_DEBUG_RETURN: Set to the desired return value of the command

# From zsh docs: "If a q- is given (only a single q may appear), a minimal form
# of single quoting is used that only quotes the string if needed to protect
# special characters. Typically this form gives the most readable output."
#
# Output the command to stderr so we can pipe the result of this to other
# commands.
if [[ -z "$ECHO_EVAL_FINISHED" ]]; then
  export ECHO_EVAL_LEVEL=1
  ECHO_EVAL_FINISHED=1
else
  export ECHO_EVAL_LEVEL="$(( ${ECHO_EVAL_LEVEL:-0} + 1))"
fi
local prompt_char="$"
if [[ "$EUID" -eq 0 ]]; then
  prompt_char="#"
fi
if [[ "$ECHO_RUN_DEBUG" == "1" ]]; then
  echo -n "${fg_bold[blue]}(DEBUG MODE) " >&2
fi

if [[ "$ECHO_EVAL_LEVEL" -gt 1 ]]; then
  prompt_char=">"
  local x
  for x in {2..${ECHO_EVAL_LEVEL}}; do
    prompt_char="==${prompt_char}"
  done
fi

echo "${fg_bold[blue]}${prompt_char} ${@}$reset_color" >&2

if [[ "$ECHO_RUN_DEBUG" == "1" ]]; then
  export ECHO_EVAL_LEVEL="$(( ECHO_EVAL_LEVEL - 1))"
  return "$ECHO_RUN_DEBUG_RETURN"
fi
eval "$@"
export ECHO_EVAL_LEVEL="$(( ECHO_EVAL_LEVEL - 1))"
