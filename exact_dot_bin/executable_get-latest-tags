#!/usr/bin/env bash

# Gets the latest tags by date and by version, and verifies that they are the same

num_tags=1

die() {
  [ "$#" -ge 2 ] && echo-err "$2" >&2
  exit "$1"
}

USAGE="usage: $(basename "$0") [<options>]

    -v, --by-version      sort by version
    -d, --by-date         sort by date
    -p, --pattern <pattern>
                          the grep pattern to search for
    -n, --num-tags <num>  the number of previous tags to return
    -g, --egrep-pattern <pattern>
                          an egrep pattern to avoid
"

remote=false

while [ "$#" -gt 0 ]; do
  case "$1" in
    -[[:alnum:]][[:alnum:]]*)
      _value="-${1##-?}"
      _arg="${1%%"${1##-?}"}"
      ;;
  esac
  if [ -n "${_arg:-}${_value:-}" ]; then
    shift
    set -- "$_arg" "$_value" "$@"
  fi
  unset _arg _value
  case "$1" in
    -h | --help)
      echo "$USAGE"
      exit
      ;;
    -v | --by-version) by_version=1 ;;
    -d | --by-date) by_date=1 ;;
    -p | --pattern)
      pattern="$2"
      shift
      ;;
    -n | --num-tags)
      num_tags="$2"
      shift
      ;;
    -g | --egrep-pattern)
      egrep_pattern="$2"
      shift
      ;;
    --remote)
      remote=true
      ;;
    --)
      shift
      break
      ;;
    -?*) die 1 "unknown option: ${1}" ;;
    *) break ;;
  esac
  shift
done

egrep_cmd=(cat)
if [[ -n $egrep_pattern ]]; then
  egrep_cmd=(egrep -v "$egrep_pattern")
fi

if [[ -z $pattern ]]; then
  echo "Invalid arguments. A --pattern= is required." >&2
  exit 1
fi

# NOTE: Ideally we'd sort by "taggerdate", but lightweight tags don't have one
# so we sort by creatordate (https://stackoverflow.com/a/71478514).
if $remote; then
  IFS=$'\n' read -r -d '' -a latest_tags_by_date < <(git ls-remote --tags --refs --sort=creatordate origin "$pattern" | cut -d '/' -f 3 | "${egrep_cmd[@]}" | tail -"$num_tags")
  IFS=$'\n' read -r -d '' -a latest_tags_by_version < <(git ls-remote --tags --refs --sort=version:refname origin "$pattern" | cut -d '/' -f 3 | "${egrep_cmd[@]}" | tail -"$num_tags")
else
  IFS=$'\n' read -r -d '' -a latest_tags_by_date < <(git tag --sort=creatordate --list "$pattern" | "${egrep_cmd[@]}" | tail -"$num_tags")
  IFS=$'\n' read -r -d '' -a latest_tags_by_version < <(git tag --sort=version:refname --list "$pattern" | "${egrep_cmd[@]}" | tail -"$num_tags")
fi

# echo "${latest_tags_by_date[@]}"
# echo "${latest_tags_by_version[@]}"

if [[ "$by_version$by_date" == "1" ]]; then
  if ((by_version)); then
    printf "%s\n" "${latest_tags_by_version[@]}"
    exit
  elif ((by_date)); then
    printf "%s\n" "${latest_tags_by_date[@]}"
    exit
  fi
fi

debug_output() {
  echo-err "$*" >&2
  for i in $(seq 0 "$((num_tags - 1))"); do
    if [[ ${latest_tags_by_date[$i]} != "${latest_tags_by_version[$i]}" ]]; then
      echo-err "index $i: ${latest_tags_by_date[$i]} != ${latest_tags_by_version[$i]}" >&2
    else
      echo-ok "   index $i: ${latest_tags_by_date[$i]} == ${latest_tags_by_version[$i]}" >&2
    fi
  done
  exit 1
}

if [[ ${#latest_tags_by_date} != "${#latest_tags_by_version}" ]]; then
  debug_output "Different number of tags returned (date: ${#latest_tags_by_date}, version: ${#latest_tags_by_version})"
  exit 1
fi

if [[ ${#latest_tags_by_date[@]} -eq 0 ]]; then
  debug_output "No matching tags by date."
  exit 1
fi
if [[ ${#latest_tags_by_version[@]} -eq 0 ]]; then
  debug_output "No matching tags by version."
  exit 1
fi

for i in $(seq 0 "$((num_tags - 1))"); do
  if [[ ${latest_tags_by_date[$i]} != "${latest_tags_by_version[$i]}" ]]; then
    debug_output "Tags sorted by date and version do not match"
  fi
done

printf "%s\n" "${latest_tags_by_version[@]}"
